## Redis实战

感觉实战里面很多的东西没必要第一时间就学，所以看的都是基础为主。

还有类似分布式锁等非常非常重要的组件功能。



### Redis基础

Redis是一种**内存型K/V型NoSQL（非关系型数据库）**。

详细的命令可以直接从中文官网看：[Redis命令](https://redis.io/commands)



#### 基础命令

- 省略在基础不过的GET、SET命令

##### 过期时间相关指令

| 命令    | 作用             |
| ------- | ---------------- |
| EXPIRE  | 设置键的过期时间 |
| PERSIST | 移除键的过期时间 |
| TTL     | 查询剩余过期时间 |

- 以上指令都还有一套用于UNIX时间的命令版本

##### 事务相关命令

| 命令 | 作用 |
| ---- | ---- |
|      |      |
|      |      |
|      |      |

​		Redis中的事务基本等同于MYSQL的事务

​		由MULTI和EXEC包裹的命令会一次性到服务端执行，保证命令的原子性等

​		事务命令也可以用来加速客户端的效率，将多次请求打包在MULTI和EXEC中执行可以减少其中命令和结果在网络中的传播时间，提高效率



#### Redis的基础数据结构

##### String - 字符串

​		Redis中的字符串类似于C语言中的String

​		字符串可以存储以下三种类型:**字节串，整数，浮点数**

 - Redis字符串可以看作二进制位串（Bit string）

   | 命令          | 作用                       |
   | ------------- | -------------------------- |
   | GETBIT/SETBIT | 获取/更新二进制位串的某位  |
   | BITCOUNT      | 统计二进制位串中1的个数    |
   | BITOP         | 位运算（AND，OR，XOR，NO） |

   - 二进制位串可以作登录统计，每日签到等节省空间也方便计算

- 常用命令

  | 命令              | 作用       |
  | ----------------- | ---------- |
  | INCR/DECR         | 自增/自减  |
  | APPENT            | 字符串拼接 |
  | GETRANGE/SETRANGE | 子串操作   |

  - 虽然INCR/DECR都为原子操作，但对客户端来说也并非线程安全（以前记得一句话，现在读起来感觉有问题）。

##### List - 列表

- Redis的列表允许用户从序列的两端推入或弹出数据（类似于堆栈）

- 常用命令：

  | 命令        | 作用                                             |
  | ----------- | ------------------------------------------------ |
  | LPUSH/RPUSH | 从左边/右边推入数据                              |
  | LPOP/RPOP   | 从左边/右边弹出数据                              |
  | LRANGE      | 获取一段范围的数据                               |
  | LTRIM       | 修剪列表，只保留start和end之间的元素（左闭右闭） |

  ​		借由以上命令,Redis的List完全可以作为消息队列使用

  ​		另外还有部分阻塞式POP命令，BLPOP/RLPOP，若队列中元素为空则阻塞TIMEOUT秒

- List间的元素交流

  | 命令       | 作用                      |
  | ---------- | ------------------------- |
  | RPOPLPUSH  | 弹出右边元素,推入目标左边 |
  | BRPOPLPUSH | 阻塞式                    |

  ​		以上命令可能不会常见，但将POP和PUSH合成一个命令之后省去了客户端自己POP数据的步骤，在元素移动时效率能高很多



##### Set - 集合

​		Redis的集合以无序且无重复的方式存储不同的元素。

- 常用命令：（相比于前两个结构来说集合对我来说陌生多了）

  | 命令        | 作用                                      |
  | ----------- | ----------------------------------------- |
  | SISMEMBER   | 检查元素是否存在于集合                    |
  | SCARD       | 返回集合中的元素数量                      |
  | SRANDMEMBER | 随机返回一个或多个数字，count为正时不重复 |
  | SPOP        | 随机弹出一个元素，并返回                  |
  | SMOVE       | 原集合中包含则将元素移动到目标集合        |

- 多集合交互命令

  | 命令                 | 作用             |
  | -------------------- | ---------------- |
  | SDIFF、SDIFFSTORE    | 差集、差集并转存 |
  | SINTER、SINTERSTPORE | 交集、交集并转存 |
  | SUNION、SUNIONSTORE  | 并集             |

  



##### Hash - 散列表

​		散列可以让用户将多个键值对存储到一个Redis键里

​		概念上完全可以理解为Java中的HashMap，可能实现方式不一样

- 常用命令：

  | 命令                  | 作用                     |
  | --------------------- | ------------------------ |
  | HMSET/HMGET/HGET/HSET | 设置或获取值             |
  | HDEL                  | 删除                     |
  | HLEN                  | 返回键值对数目           |
  | HKEYS/HVALS/hGETALL   | 获取所有的键、值、键值对 |
  | HEXISTS               | 检查给定键是否存在       |
  | HINCRBY               | 指定键增加指定值         |

  ​	在我的看法里Hash的作用应该是这些结构里面最大的。





##### Zset - 有序集合

​		有序集合从概念上来讲就是在集合的基础上为集合中的每个元素映射一个分值，使其有序。

​		有序集合提供了分值处理命令以及根据分值大小有序的获取或扫描成员和分值的命令

- 常用命令	

  | 命令      | 作用                               |
  | --------- | ---------------------------------- |
  | ZCARD     | 获取有序集合中的成员数量           |
  | ZCOUNT    | 返回分值处于指定参数之间的元素个数 |
  | ZRANGE    | 返回排名处于指定参数之间的元素     |
  |           | 处于分值处于参数之间的元素         |
  | ZSCORE    | 返回元素分值                       |
  | ZADD/ZREM | 新增、删除                         |

  有序集合应该是我最不熟悉的部分了

  可以作线上的排序，例如热度文章排行，游戏中的战力名次排行等等



### Redis的持久化

Redis提供了以下两种持久化的操作：

​		**快照（snapshotting）**，简单来说他可以将某一时刻中Redis里的所有数据写入硬盘，确保断电不丢失

​		**只追加文件（append-only file AOF）**，会在执行命令的时候就将命令复制到硬盘，恢复即为重新执行命令

#### 快照（snapshotting）

​		类似于MYSQL中的快照，Redis中的快照也可以理解为一个临时创建的副本。

​		根据Redis的**dbfilename**配置项，快照将被写入指定的文件，文件存放在**dir**配置项指定的路径。

​		Redis崩溃之后的恢复会导入最后一次快照的数据。所以缺点也很明显：

​		恢复会丢失上次快照到崩溃时间的所有数据，但当数据量很大的时候配置频繁的快照操作会让Redis的性能大打折扣。

##### 创建快照的方法

  1. **BGSAVE**

     服务端接收到**BGSAVE**的命令之后，会`fork`创建一个子进程来负责快照的创建和落盘，父进程继续响应客户端的骑牛。

		2. **SAVE**

     **SAVE**就是**BGSAVE**的阻塞版本，在**SAVE**命令完成之前Redis服务端不会响应任何的命令

		3. 配置项`save`

     `save 60 10000`  表示60s内有10000次的写入就执行**BGSAVE**

		4. **SHUTDOWN**和**TERM**

     在关闭服务器之前会执行**SAVE**，将当前数据全部落盘

		5. **SYNC**

     **SYNC**用于集群间的数据同步，从服务器向主服务器发送这个命令之后，如果当前主服务器的快照过旧就会触发**BGSAVE**

##### 验证快照文件命令

​	`redis-check-dump`





#### AOF

​		**AOF**模式下，Redis会将**写命令**都写入AOF文件的末尾。

​		`appendsync` - 控制AOF频率的配置项，包括`always`，`everysec`，`no`  

​		相对于快照持久化的方式来说，AOF持久化能在不影响服务器性能的情况下尽量的减由于崩溃而损失的数据（崩溃      

只会损失上次AOF写入之后的数据），但AOF也有缺点 - 数据恢复，和快照的恢复不同AOF的恢复需要重新执行文件中的      

指令，如果AOF文件过大会导致恢复的时间也会被拉长到无法接受，另外AOF也会不断消耗硬盘的空间

​			为了解决AOF文件体积问题，Redis引入了`BGREWRITEAOF`命令：该命令会通过移除AOF文件中冗余的命令来尽 

可能的缩小AOF文件体积，同时也减少了其中写命令的数量，降低恢复消耗的时间。

###### 自动BGREWRITEAOF的配置项

​		`auto-aof-rewrite-percentage` 

​		`auto-aof-rewrite-min-size`

```shell
// 在文件体积大于64mb,并且比上一次重写之后大一倍的情况下执行BGREWRITEAOF
auto-aof-rewrite-percentage 100 
auto-aof-rewrite-min-size   64MB
```

##### 验证AOF文件的命令

​		`redis-check-aof`

​		该命令会扫描AOF文件直到第一个错误命令，并删除其后的所有命令。





### Redis的主从复制

​		在集群环境下，一般采用**主从**的形式，主服务器会向从服务器发送更新，并使用从服务器来处理所有的读请求，

而写命令全在从服务器完成。

​		这时候就需要复制（replication），复制可以让其他的服务器也有一个不断更新的数据副本，保证数据的正确性。

​		在接收到主服务器发送的数据初始副本之后，客户端每次向主服务器进行写入时，从服务器都会**实时**更新。



#### 主从复制的配置 



