### JMM - JavaMemoryModel

  	简单理解,暂不深入。 (〃'▽'〃)

![运行时内存区域](https://github.com/CheNbXxx/StrugglingInJava/blob/master/all_demo/src/main/img/c9ad2bf4-5580-4018-bce4-1b9a71804d9c.png)

---

#### Java 内存区域

- 方法区    `Method Area`
  - **线程共享**区域，主要用于存储**已被虚拟机加载的类信息，常量，静态变量以及及时编译器编译后的代码**。
  - **运行时常量池**
    - 在编译器被确定，并被保存在已编译的`.class`文件中的一些数据，包含类、方法、接口等中的常量，也包含字符串常量。
  - 不需要连续的内存区域。
- 堆    `Java Heap`
  - **线程共享**区域，在虚拟机启动时就创建，是虚拟机中占用内存最大的一块区。
  - 所有的对象都在这里分配内存，所以也是垃圾收集的主要区域，又称为`GC堆`。
  - 不需要连续的内存，也可以动态增加其内存。
- 程序计数器    `Program Counter Register`
  - 属于**线程私有**的数据区域，占内存不多，主要代表**当前线程所执行的字节码行号指示器**。通过改变这个计数器的值来选取下一条需要执行的字节码指令，完成分支，循环 ，跳转，异常处理，线程相关等操作。
  - 如果执行的是`Java`方法，记录字节码的的指令地址，如果执行`Native`，则为空`Undefine`。
- Java虚拟机栈    `Java Virtual Machine Stacks`
  - 属于`线程私有`的数据区域，代表`Java`方法执行的内存模型。
  - 每个方法执行时都会创建一个栈桢来存储方法的变量表、操作数栈、动态链接方法、返回值、返回地址等信息。
  - 生命周期和线程相同。
- 本地方法栈    `Native Method Stacks`
  - 同属于**线程私有**的数据去用，主要和`Native`方法相关。



---



#### JMM概述

- `JMM`是一种抽象的概念，简单地说是一种描述程序访问变量或者方法的规则或规范。

- `JVM`运行程序的实例是线程`Thread`，每个线程在创建时`JVM`都会为其分配一个`工作内存(线程栈)`，用于存储各`Thread`的私有数据，但`Java`的变量和对象实例等都存储在`主内存`，执行时`Thread`将数据从`主内存`拷贝到自身的`工作内存`，**线程间的通信也必须通过主内存完成**

- `方法区`和`堆`存在于`主内存`,而`虚拟机栈`、`本地方法栈`以及`程序计数器`存在于`工作内存`。


#### JMM相关特性

- 原子性
  - 指的是一个操作的不可中断性，于`SQL事务`的原子性类似。
- 可见性
  - 指的是在多线程情况下，一个现场修改了某属性，其他线程也能立即知道这个修改的属性的值。
- 有序性
  - 简单理解为代码的执行是按顺序依次执行的。



#### 指令重排序 

- 编译器优化重排
  - 编译器再不改变单线程程序语义的前提下，可以对语句进行重新排序。
- 指令并行重排
  - 现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性(即后一个执行的语句无需依赖前面执行的语句的结果)，处理器可以改变语句对应的机器指令的执行顺序。	
- 内存系统重排
  - 由于处理器使用缓存和读写缓存冲区，这使得加载(load)和存储(store)操作看上去可能是在乱序执行，因为三级缓存的存在，导致内存与缓存的数据同步存在时间差。