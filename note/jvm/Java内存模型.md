## Java内存模型

- 2020.03.18
- 内存模型算是基础吧，看了很多但是并不能很好的向别人描述其概念，今天整理以下。
- 断断续续写点吧，感觉理解不是很好

Java内存模型时JVM为了屏蔽底层硬件的异构性而设计的一套规范，主要用于多线程之间满足原子性，可见性，有序性。

---



<!--more-->

### 原子性  

指一个或多个操作要不全部执行且中间不可中断要不就不执行。

JMM中提供了八种原子性指令：

1. lock(锁定)：作用于主内存中的变量，它把一个变量标识为一个线程独占的状态；

2. unlock(解锁) ：作用于主内存中的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁；

3. read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便后面的load动作使用；

4. load（载入）：作用于工作内存中的变量，它把read操作从主内存中得到的变量值放入工作内存中的变量副本；

5. use（使用）：作用于工作内存中的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个

   使用到变量的值的字节码指令时将会执行这个操作；

6. assign（赋值）：作用于工作内存中的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作；

7. store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送给主内存中以便随后的write操作使用；

8. write（操作）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中；



对于lock和unlock指令来说，lock指令执行之前会清空当前工作内存中此变量的值，而从主内存中重新获取，unlock指令则会使此变量被刷新回主内存。

因此程序员可以使用lock和unlock去实现更大粒度的原子性，JVM并没有开放lock和unlock指令，但是提供了两个字节码指令monitorenter和monitorexit，也就是synchronized的实现方法之一。

而volatile则无法实现程序的原子性。





### 可见性  

线程对一个变量的修改对于另外一个线程来说是否可见。





### 有序性 

即程序执行的顺序按照代码的先后顺序执行。

通常，为了获得更高的执行效率编译器和CPU都会对指令进行重排序。

根据as-if-serial语义，单线程环境下任何重排序都不能改变程序的执行结果，但是在多线程环境下却可能破坏其执行语义。

另外在上下文数据具有依赖性时，也会禁止重排序。

Java中volatile和synchronized都提供了有序性保证。

synchronized保证了临界区的互斥，当一段代码只有单个线程在执行的时候，根据as-if-serial语义，则可以认为他是有序的。





### 参考文章

[Java内存访问重排序的研究](https://tech.meituan.com/2014/09/23/java-memory-reordering.html)