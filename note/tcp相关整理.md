## TCP相关整理

- 基于《TCP/IP详解 卷一》和谢希仁《计算机网络（第6版）》的简单整理和总结。



TCP是一种面向连接的，基于字节流的，可靠的传输控制协议。

属于OSI七层模型中的传输层。

### 内容梳理

![1568734229571](/home/chen/.config/Typora/typora-user-images/1568734229571.png)

- hhhh,暂时梳理随时改

### 一、TCP报文首部

![](/home/chen/Desktop/9rzlJf.png)



TCP首部大小在20~60字节，其中标准长度为20个字节。

**源端口和目的端口**

TCP的四元组为源IP，源端口，目的IP，目的端口，**TCP首部中的源端口和目的端口结合IP首部中的源和目的IP地址组成了一个连接的四元组。**

**序号/序列号(SEQ)**

在一个TCP连接中唯一标识TCP报文段，是重传机制的重要字段。

自ISN（初始序列号）起，单调递增。

**确认号(ACK)**

接收端发送给发送端，是期望对方下一个报文段的第一个字节的序号。

**值为N的ACK报文表示的是序号在N之前的报文全部已经收到，希望收到序号N的报文。**

**数据偏移**

表示TCP数据部分相对于整个TCP报文段来说的偏移量，可以简单理解为TCP首部的长度。

**控制位**

1. URG - 紧急，置位后首部紧急指针生效
2. ACK - 确认，置位后确认号生效
3. PSH - 推送，置位后接收方应尽快给应用程序推送该段数据
4. RST - 重置，置位后表示该报文为重置报文，取消连接
5. SYN - 初始化，置位表示为初始化报文，用于初始化TCP连接
6. FIN - 结束，职位表示当前端结束数据传输工作

**URG之前还有CWR - 拥塞窗口 以及 ECE - ECN回显，但是在一些TCP的实现里面并没有实现这两位。**

**窗口**

**通常在ACK报文中附带，作为接收方对发送方的背压，是影响发送端发送速率的因素之一。**

占16位，单位为字节，所以在没有**窗口缩放**选项的情况下，最大为65535字节。

**校验和**

**报文段正确性校验使用，**占两位。

校验范围包括首部和数据部分，和UDP一样需要再生成12字节的伪首部参与计算。

伪首部包括源和目的IP，保证通信双方的正确性。

**紧急指针**

只有在**URG控制位**置位的情况下生效。

表示紧急报文在**报文段序列号字段**上的正偏移，序列号超过紧急指针的即为正常数据。

零窗口的情况下也可以发送紧急报文。

**选项**

**1. MSS - 最大报文段长度**

连接中每个TCP报文段的**数据字段**的最大长度，不包含首部。

在SYN报文中协商，双方都可以指定自己的MSS，甚至可以不同，默认为536字节。

**2. SACK - 选择确认**

当接收方接受到乱序数据时，就会在接收窗口产生缺口。

设置SACK选项就是为了描述这些缺口信息，使发送方更好，更准确的重传这些缺口数据。

**3. WSCALE/WSOPT - 窗口缩放**

由于首部的**窗口大小**字段仅占16位，所以影响的范围也仅在0~2^16(65535)之间。

该选项就是为了增加窗口大小字段的范围，从16位提升至30位。

该选项只能出现在一个SYN报文段中，而SYN报文仅仅在初始化时通信双方各发一次，由此可知：

**连接建立之后窗口缩放的比例因子是与方向绑定的**，通信双方的比例因子可以不同。

**4. TSOPT - 时间戳选项** 

该选项要求发送方在每一个报文中添加2个4字节的单调递增的时间戳数值。

分别是：**TSval/TSV 发送时间戳 以及 TSecr/TSER 时间戳回显**。

该选项的设置可以很好的解决重传的二义性，也能更加精确的计算RTT。

**5. 其他**

另外的还有**认证选项**以及**用户超时选项**等等。



### 二、连接管理



#### 建立连接

稍微有点常识的程序猿应该都知道，TCP建立连接的时候需要往返发送三个报文。

   ![1568818645296](/home/chen/.config/Typora/typora-user-images/1568818645296.png)

1. 连接发起者(客户端)会向服务端发送一个**SYN报文**，报文中除了目的端口，还包括ISN(初始序列号)以及部分选项字段。
2. 服务端接受后会回复一个**SYN报文**作为响应，然后将接收到的SEQ+1，作为报文的ACK值，并指明服务端的的初始序列号等信息。
3. 客户端响应一个ACK报文，同样的将服务端SYN报文中的SEQ+1作为ACK值。

##### 为什么要三次握手

首先明确，**三次握手的主要目的是交换双方的ISN以及选项。**

这些字段，例如是否启用SACK等都将是数据传输时的重要属性。

交换双方的信息至少需要两次握手，而第三次握手则是为了**防止已失效的连接请求又被转发到了服务端**。

意思就是如果客户端在收到服务端的SYN+ACK报文时就建立一个连接，那么在上述情况下将会出现先后多条连接的情况。

四元组一样无法建立相同连接，但是可以先后。

我感觉可能防止建立重复连接的功能可能是意外之喜。

另外**可以发现SYN报文也占用了一个序列号。**



#### 初始序列号 - ISN

在发送用于建立连接的SYN报文时，通信的双方都会选择一个初始化序列号。

每个连接都会有不同的初始化序列号。

目前，我还不清楚SYN报文的重传会不会导致SEQ的变化，如果并不会的话，那重传的SYN报文在服务端就可以拦截下来。

《TCP/IP详解》的原文在13.2章节:**此外，为了确认客户端的SYN，服务器将其包含的ISN(c)数值加1后作为返回的ACK数值。因此，每发送一个SYN，序列号都会自动加1。这样如果出现丢失的情况，该SYN段将会重传**



#### 关闭连接

相对来说关闭连接的四次挥手就好理解多了。

   ![1568820312811](/home/chen/.config/Typora/typora-user-images/1568820312811.png)

1. 连接的主动关闭方，发送一个FIN。
2. 被动方回复一个ACK。
3. 被动方主动发送一个FIN。
4. 主动方回复一个ACK

##### 为什么要四次挥手

相比于三次握手来说，可以看作是被动关闭方的FIN报文和ACK拆开了，而三次握手的SYN报文和ACK是一起发出的。

至于为什么要拆开，我的理解是因为半关闭状态的存在，作为一个全双工的协议，连接的双方都可以互相发送数据。

某一端发送了FIN报文就表示己方的数据发送完毕，而等待对象的FIN。

主动关闭方发送了FIN报文之后就停止向对端发送数据，而是只做承接并响应ACK。

因此就分别需要两个FIN报文和两个ACK才足以完整的关闭一条(全双工)连接。



#### 半关闭状态

半关闭状态是指TCP连接双方，有一端发送了FIN，而另一端还在继续传输数据，此时的主动关闭方仍然会对接收的数据作ACK的响应。 



#### 同时打开和关闭

##### 同时打开

通信双方在收到对方的SYN报文之前，先发送了一个自己的SYN报文，此时这种情况就叫做**同时打开**。

算是一种很少出现的特殊情况，但是TCP也能支持，并建立一条正常的连接。

​    ![](/home/chen/Desktop/740952-20161107133303264-146495245.png)

<font size="1">我的画图软件不能支持斜线，只能靠盗图了</font>

如图可见，通信的双方同时向对方发送一个SYN，并附带上自己的ISN(SEQ)。

接收方接受之后同样也同时作为被动发起方恢复一个ACK。

**此时通信双方即为客户端也为服务端，状态的变化一致，且回复的ACK中ISN与SYN中的一致。**

通信双方经历了相同的状态变更:`SYN_SENT` -> `SYN_RCVD` -> `ESTABLISHED`

<font size="2">我感觉TCP内部的实现中应该也是以SEQ作为参考依据。</font>

##### 同时关闭 

  ![](/home/chen/Desktop/20170410153759607.png)

和同时打开差不多，**同时关闭是在收到对方的FIN之前，向对方发送了自己的FIN报文。**

同样的通信双方经历了相同的状态变更:`FIN_WAIT_1` -> `CLOSING` -> `TIME_WAIT`

可以看到双方是都需要等待一个2MSL的。



#### 半打开，半关闭，半连接

以上是TCP连接中的三种特殊状态，就简单的叙述一下吧。

半连接是指**服务端发送了SYN+ACK报文之后，等待客户端的ACK报文的这段时间**

半连接有类似的攻击手段:大量的请求发送到服务端但是永远不回复最后的ACK，导致服务端存在大量的半连接。

半打开是指**如果一方已经关闭或异常终止连接，而另一方却不知道。**

半关闭上面也有提到过，**通信的一方主动发送FIN之后表示本方不会再主动发送任何数据，但仍然可以接受对方的数据并响应的情况。**



### 三、TCP的有限状态机

![](/home/chen/Desktop/9c4cd42ce7dfa8bb245ae685e7ad8151.png)

上图即为《TCP/IP详解 卷一》中的原图。

图中基本包含了全部的TCP连接状态变更，包括典型、非典型。



#### ESTABLISHED

`ESTABLISHED`状态是通信双方正常传输数据的状态。

作为三次握手的终点和四次挥手的起点。



#### TIME_WAIT状态

**`TIME_WAIT`状态是主动关闭方在连接关闭的最后阶段必须经历的。**

在**WAIT_TIME**状态下，主动关闭方会判断本次的四元组不可用，所以此时就算对端接收到ACK释放连接之后，重新请求SYN，也会被拒绝。

该状态，**TCP将会设置时间等待计时器(TIME_WAIT timer)，并等待2MSL的时间才会真正的释放连接，RFC793中建议为2min。**

MSL(Maximum Segment Lifetime)，也可以称为最大报文生存时间，**是报文在所有链路中存在的最大时间，超过就会被丢弃。**

这么做的目的有以下两个：

1. 为了保证最后的ACK能够到达被动关闭方。

从有限状态机的图中也可以看到，被动关闭方的连接真正释放是在收到最后一个ACK之后，所以必须要保证ACK的正确发送。

**等待2MSL能够有效避免最终的ACK丢失的情况，ACK不会主动重传，但是对端的FIN会重传直到收到正确的ACK为止。**

2MSL可以粗略的看做是己方ACK发送的时间和对方FIN重传的时间。

当一个报连接处于`TIME_WAIT`状态时，任何延迟到达的报文都会被丢弃，只接收FIN报文。

另外**TIME_WAIT**的状态是从最后一个ACK发送开始，所以重新响应ACK之后，**TIME_WAIT**也会重新计时。

2. 保证相同四元组额前后连接报文不混淆

**等待2MSL，就可以使本次连接的报文在链路中全部消失。**

期间TCP会将本次四元组定义为不可用，阻止重连。

如果不等待，相同四元组的连接如果重连，就有可能导致旧报文发送到新连接的情况，造成数据混乱。

2MSL是相对保守的处理方式，在ISN能超过上一次连接的最大序列号或者启用了时间戳选项的时候，感觉上可以跳过。



#### CLOSING 状态

`CLOSING`状态是TCP的非典型状态<font size=2>(一般情况下不会出现）</font>。

只有在上文提到过地**同时关闭**的情况下才会出现，同时关闭的通信双方在接收到对方的FIN，在发送ACK之后进入到`CLOSING`状态。

处于`CLOSING`状态下的通信双方在接收到对方的ACK之后，都会进入`TIME_WAIT`状态。



### 四、TCP的重传机制

TCP协议往下就是网络层的IP协议，但是IP协议并不提供任何可靠传输的保证，所以我们可以任务TCP所处的链路是不可靠的。

但是TCP介绍中也说了，它提供的是**可靠的传输服务**，因此也就要求TCP协议自身来补足IP协议中的不可靠部分。



#### 可靠传输的基础

**首先明确，TCP的重传机制是基于`连续ARQ协议`实现的。**

维基百科对ARQ的解释如下：

> ARQ协议，即自动重传请求（Automatic Repeat-reQuest），是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。

##### 停止等待ARQ协议

应该是最简单的`ARQ协议`了。

 ![](C:\Users\bingxin.chen\Desktop\chen\github\StrugglingInJava\pic\20160313194700419.png)

**一个分组一个分组的发送，在收到确认之前都不会发送下一个分组，如果出现超时就重传该分组。**

但是显而易见的，**该协议的利用率很成问题**，在发送完一个分组到确认到达的这段时间信道都是空闲的。

即使整个链路十分可靠，但依旧被要等待确认信息。

而且判断分组是否丢失的算法就是**在一定时间内，是否收到接受的确认信息**。<font size=1>(太粗暴了)</font>

##### 连续ARQ协议

`连续ARQ协议`可以说是对`停止等待ARQ协议`的优化。

**保留确认和超时机制的情况下，改为一次性发送多个分组，并等待这些分组的确认信息**

 ![](C:\Users\bingxin.chen\Desktop\chen\github\StrugglingInJava\pic\20160313194725494.png)

连续ARQ协议虽然提高了信道利用率，但是仍然会存在一些问题，此处不展开来说。



#### 确认机制

确认机制是ARQ协议的两个重点之一。

**确认机制指的就是接收端在收到一个正确的报文时，会给发送端回传一个ACK，表明报文已经到达。**

##### 延迟确认/累计确认

**接收端在收到数据之后，并不会立马回传ACK，而是会延迟一定的时间(延迟确认)，发送的时候会以最大有序报文的序号作为ACK依据(累计确认)。**

这样的目的很明确就是**降低ACK造成的网络负担。**

##### 选择确认SACK

选择确认是TCP首部中的选项，启用SACK功能需要通信双方事先确认，之前也说过是SACK就是为了**描述接收端的接收缺口，帮助发送方更加准确的重传丢失报文。**

可以在一个ACK报文中，指明多个缺口信息(最多三个)，普通的ACK报文可以看做是单个的缺口信息。



#### 超时重传

**超时重传又可以称为基于计时器的重传。**

TCP每发送一个报文，都会设定一个**重传计时器**，若在计时器超时时都没有收到确认消息，就会触发重传操作。

超时重传的整体逻辑并不复杂，但是**超时时间的选择**却是TCP最难的问题之一。

简单的设置，比如SYN的重传，每次SYN重传的超时时间都是上一次的简单加倍，比如说上次过了2s之后重传报文，这次就应该等待4s或者6s，这种方式称为**二进制指数退避**。

复杂一点的就会根据报文的RTT推算RTO。

> RTT （报文段往返时间）- 从报文发出到接受到该报文的ACK所花费的总时间。
>
> RTO （超时重传时间）- 从报文发出到重传报文所花费的时间，也就是所谓的重传超时时间。

<font size=1>这里并不是很懂，就先空着了</font>



#### 快速重传

快速重传是基于接收端反馈信息的重传模式。

**在TCP中，接收方如果收到一个失序的报文段就会立即发送重复的ACK，而不会选择延迟或者累积。**

因此如果接收端的接收缓存中出现缺口，那么后续到达的报文就会 重复确认同一个报文。

简单的举个例子：

接收端的缓存中存在的是报文1,2,3,4，且还未发送ACK，如果此时报文6到达，那么接收端就会立马发送一个ACK=5的报文，如果报文5一直没有到达，那么在报文7,8,9到达时，都会发送一个ACK=5的重复确认报文。

**发送方接收到的重复确认报文达到一定阈值(通常为3)之后，就会立马重传确认报文中指明的报文。**



#### 伪重传的判定和响应

伪重传就是指在没有发生数据丢失时，但仍然进行了重传的情况。

导致伪重传的原因有超时时间误差，包失序，包重复或者ACK丢失等。

判定是否是伪重传的方法有以下集中：

1. **DSACK 重复的SACK**

   对SACK的增强，**可以在第一次SACK块中可以指明接收端中重复收到的报文端序列号。**

2. **Eifel检测算法**

   该算法需要首部中的时间戳选项支持。

   TCP会在重传的的时候记录下重传报文的TSV，当接收到重传报文是会对比回显TSER和保存的TSV对比。

   如果TSER < TSV，则表示是伪重传。

DSACK只能在接收到重传的ACK之后才能判断此次是否是伪重传，而Eifel检测算法是在第一个ACK到达时，就能判断出来，可能此时重传报文都还没传输到接收端。



#### 重复、失序以及重新组包

##### 失序

包失序可能由IP协议或者链路状态引起，因为IP协议不能保证包的有序发送，而且就算是有序发送但是在动态的网络中也不能保证包有序的到达接收端。

上文也有提到过，当接收到一个失序的报文时，接收端会立马响应一个ACK。

少量的失序并不会造成什么影响，但如果失序报文间隔的报文数目超过快速重传的阈值，就会触发重传，还是伪重传。

##### 重复

《TCP/IP详解 卷一》中也说了IP协议可能出现单次包传输多次的情况，因此也就产生了重复问题。

重复次数过多也就会触发重传。

##### 重新组包

- 需要在看些资料



