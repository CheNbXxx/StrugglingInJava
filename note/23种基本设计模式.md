# 23种基本设计模式

> 2020/06/08
> 半个月没看技术相关的了，希望通过对设计模式的重新整理找回学习的状态吧。



---



## 设计模式的七大法则

也可以理解为好的代码结构需要遵守的七大法则。



### 开闭原则

对扩展开放，对修改关闭。

对扩展开放的意思，在我理解中就是类应该要易于扩展，有什么功能变更的或者添加的时候不应该直接去改主逻辑，而是通过扩展的形式。



### 里氏替换原则

替换就是指在所有使用父类的地方，可以用子类代替。

也就是说子类必须扩展父类的原有功能，但不能修改原有的功能。

里氏替换原则可以说是开闭原则的具体实现或者说进一步补充。



### 依赖倒置原则

类之间的依赖需要按照一定的规则顺序，高层抽象类不能依赖底层的具体实现。

比如在接口方法中定义子类为入参类型。

违背依赖倒置原则会大大增加类间的耦合性不利于代码维护。



### 单一职责原则

简单理解就是希望类的功能尽量单一，一个类不应该承载太多的职责。

降低类的复杂度，减小类的实现粒度，都有利于减小类之间的耦合性，方便后期维护。



### 接口隔离原则

和单一职责原则很相似，在我理解可能就是规定的对象不同，接口隔离就是特指接口。

面向接口编程，一个接口不应该承载太多的特性。

简单理解该原则，可能就是规定接口的粒度需要尽量的小。

比如Java中的Closeable之类的接口？或者Spring中的各类顶级接口。



### 合成复用原则

该原则规定，要**尽量使用组合或者聚合等关联关系来代替继承关系来实现类之间的关联。**

继承就表示子类和父类之间的高耦合度，父类的任何改动都会影响到子类，且对子类会产生一些约束和限制，不利于扩展。



### 迪米特法则

该法则规定如果两个类没有直接关系，那么就不应该产生直接的相互调用，可以通过第三方转发该调用。

该法则提高了类之间的独立性，降低了耦合度。

SpringBoot中对BeanFactoryPostProcessor的调用可能就是这个法则吧。





## 设计模式的分类

根据目的来分设计模式可以分为创建型，结构型和行为型。

创建型模式主要着力于对象的创建过程，将创建和使用过程分离。

结构型模式主要着力于对象的继承和实现，如果通过一些基本接口和对象组成一个更大的结构，和期间应该注意的点。

行为型模式主要描述类之间的调用关系，规范化方法和方法的职责，用于描述类或对象之间协作的过程。



## 创建型模式

### 单例模式（Singleton）

最常用的设计模式之一。

单例模式必须保证类实例在系统中的唯一性，好处估计也不用我多说。

类似一些重量级对象都可以使用单例模式实现，提供一个全局的访问点。

单例模式主要有以下几个特点：

1. 构造函数私有化，阻止类外部的初始化
2. 类内部持有自身实例引用
3. 提供一个对外的获取接口

类图如下：

 ![image-20200610235339938](/home/chen/github/_java/pic/image-20200610235339938.png)

单例模式的持有和创建都在类自身里面。

基本的单例模式如下：

首先是饿汉模式：

```java
public class HungrySingle{
    	// 内部持有实例引用
    	private static final HungrySingle INSTANCE = new HungrySingle();
    	
    	// 私有化构造函数
    	private HungrySingle(){
            	// 私有化之后，JVM也不会自动生成一个public的无参构造
        }
    
    	// 提供统一的话获取方法
    	public static HungrySingle getInstance(){
            	return INSTANCE;
        }
}
```

饿汉模式的特点就是在类加载时候就会实例化对象，通过JVM的类加载机制保证实例的唯一性。

对于静态变量，在准备阶段就会分配一个系统的默认值。

而另外一种懒汉模式，则是在此基础上增加了懒加载的特性只有在需要的时候才会调用。

```java
public class LazySingle{
    	private static final LazySingle INSTANCE;
    
    	private LazySingle(){}
    
    	public static LazySingle getInstance(){
            	if(INSTANCE == null){
                    	INSTANCE = new LazySingle();
                } 
            	return INSTANCE;
        }
}
```

只有在第一次调用getInstance方法的时候才会初始化实例对象。

但以上代码并非是线程安全的，多线程环境下可能仍然会创建多个实例对象。

为了保证懒汉模式的线程安全性，确保只会实例对象的唯一性，又有了静态内部类，枚举以及耳熟能详的双重检查锁模式。

以下是双重检查锁的getInstance方法：

```java
public class LazySingle{
    	private volatile static final LazySingle INSTANCE;
    
    	private LazySingle(){}

        public static LazySingle getInstance(){
            if(INSTANCE == null){
                    synchronized(LazySingle.class){
                            if(INSTANCE == null){
                                	INSTANCE = new LazySingle();
                            }
                    }
            }

            return INSTANCE;
        }
}
```

使用了synchronized来保证创建过程的线程安全，用volatile保证INSTANCE的可见性。

在外先判断是否为空是必然的，而第二次加锁则是为了避免多个线程同时等待锁释放后的再一次初始化。

另外，因为在Java中`INSTANCE = new LazySingle()`并不是原子操作，简单来说先创建对象实例，然后将INSTANCE引用指向创建的实例，所以也需要volatile关键字保证INSTANCE在多线程环境下的可见性。

静态内部类的实现方式如下：

```java
public class LazySingle{
    
    	private LazySingle(){}
    
    	private static class InstanceHolder{
            	private static final LazySingle INSTANCE = new LazySingle();
        }
    	
    	public static getLazySingle(){
            	return InstanceHolder.INSTANCE;
        }
}
```

可以看到唯一实例其实是内部类持有的。

在加载外部类的时候并不会直接加载内部类，只有在使用到内部类的相关属性的时候才会去进一步加载

也就是说只有在调用getLazySingle方法的时候，因为使用了InstanceHolder类才会去加载内部类，而静态变量也会在类加载的过程中完成初始化。

另外就是effective java作者也强烈推荐的枚举类实现方式：

```java
public class LazySingle{
    	private LazySingle(){}
    
    	private enum  InstanceHolder{
            
            	INSTANCE;
            	
            	private final LazySingle single;
            
            	InstanceHolder(){
                    	single = new LazySingle();
                }
            
            	private LazySingle getSingle(){
                    	return single;
                }
        }
    	
    	public static getLazySingle(){
            	return InstanceHolder.INSTANCE.getSingle();
        }
}
```

该种实现方式充分利用了枚举类型的特性，保证了加载的线程安全性和实例对象的唯一性。

而且是所有单利模式中唯一一种免疫序列化，反射和克隆三种破坏形式的实现。

这几种破坏方式我也没有仔细去看过，恩，单例就这样吧。





### 原型模式（Prototype）

这个可能是设计模式中简单程度仅次于单例模式的一种了，甚至于Java中它比单例更简单。

原型模式用来创建重复的对象，不同于一般的New，原型模式的对象创建用克隆来完成，对于Java来说就是Cloneable接口。

Java中的Object类就提供了clone方法，所以Java中每个类都可以使用原型模式。

而且要注意的是Java中的clone方法，会跳过构造函数的执行。

所以使用克隆方法的优势就是性能好，起码优于逐个New对象。

 ![image-20200613184728715](/home/chen/github/_java/pic/image-20200613184728715.png)

```java
public class Prototype implements Cloneable{
		// 原型类只需要提供一个克隆的方法
        @Override
        protected Object clone() throws CloneNotSupportedException {
            return super.clone();
        }
}

```

原型模式需要注意的点有：

1. 克隆会直接跳过构造函数
2. 克隆还需要注意深浅的区别



**Spring中IOC容器提供的两种基础的创建模式就是单例和原型。**



### 工厂方法模式

其实工厂模式一共有三种，除了工厂方法模式和接下去的抽象工厂模式，还有一种最基础的简单工厂模式。

工厂模式的思路很简单，**就是完全将创建和使用剥离，对象的创建交由工厂类完成，使用者并不需要知道如何创建的的对象。**

在工厂方法模式之前这个简单工厂模式也可以讲一讲。

**简单工厂模式就是将一个或者多个对象的创建交由单个工厂类完成，工厂对外提供一个创建方法包含内部的创建逻辑。**

很多情况下可以再创建方法中使用case判断区分创建不同种类的产品。

类图如下：

 ![image-20200613204354719](/home/chen/github/_java/pic/image-20200613204354719.png)

Java中简单工厂模式简单来说可以有如下的实现：

```java
// 工厂类
public class SimpleFactory {
    public Product createProduct(String productName){
            if(productName.equals("A")){
                	return new ProductA();
            }
            if(productName.equals("B")){
                	return new ProductB();
            }
       		return null;
    }
}

// 产品类接口
interface Product{
    String getName();
}

// 产品A
class ProductA implements Product{
    @Override
    public String getName() {
        return "A";
    }
}

// 产品B
class ProductB implements Product{
    @Override
    public String getName() {
        return "B";
    }
}

```

可以看到这种实现虽然也剥离了创建对象的逻辑，但是他违反了开闭原则，如果引入一个新产品，就需要新增一个创建方法，或者修改原有的创建方法，好像除了修改工厂类就别无他法。

而且一定程度上的违反了单一职责原则，一个工厂负责所有类的创建，太过繁杂。

或许对于Java来说也有以下实现：

```java
public class SimpleFactory {
        public Object createProductByClass(Class tClass) throws IllegalAccessException, InstantiationException {
            	return tClass.newInstance();
        }
}
```

额。。我也不知道该怎么说，应该说这里就完全封闭了创建的过程吧，无法插手创建的流程。

比如一个BufferReader的创建过程，原有代码是这样的：

```java
final FileInputStream in = new FileInputStream("/home/chen/xx");
final InputStreamReader in1 = new InputStreamReader(in);
BufferedReader bufferedReader = new BufferedReader(in1);
```

就算你把它合成一行，代码量也不少，如果多处调用代码就会显得很繁杂。

而且但从设计上考虑，使用类只是想要这个对象，并不需要知道对象的完整创建过程。

所以我们可以将其提取到一个工厂模式的工厂类中：

```java
public class ReaderFactory {
        public static Reader getReader(File file) throws FileNotFoundException {
                final FileInputStream in = new FileInputStream(file);
                final InputStreamReader in1 = new InputStreamReader(in);
                BufferedReader bufferedReader = new BufferedReader(in1);
                return bufferedReader;
        }
}
```

抽取了公共的逻辑出来之后，到处使用直接调用方法就好了，代码都少写很多。

但问题也明显，就比如我现在需要一个FileReader，那么就只能增加一个方法或者修改原有方法，这就和上面说的一样，它违反了开闭原则。





咳咳咳。。所以基于扩展性考虑引申除了工厂方法模式。

类图如下：

 ![image-20200613204737803](/home/chen/github/_java/pic/image-20200613204737803.png)

工厂方法模式可以算是简单工厂模式的进一步抽象。

**将工厂的创建方法抽象到工厂接口中，具体的创建逻辑延迟到具体的子类中。**

往往一个产品会对应一个工厂子类，以增加实现类的形式完成对不同产品的需求扩展。

恩。。。耦合性更低了，但是更加麻烦了，需要不同的子类。

对于上述的Reader的例子，就可以使用以下的方法：

```java
class BufferReaderFactory implements FactoryMethodInterface {
        @Override
        public BufferedReader create(File file) throws FileNotFoundException {
                final FileInputStream in = new FileInputStream(file);
                final InputStreamReader in1 = new InputStreamReader(in);
                return new BufferedReader(in1);
        }
}

class FileReaderFactory implements FactoryMethodInterface {
        @Override
        public Reader create(File file) throws FileNotFoundException {
            	return new FileReader(file);
        }
}

interface FactoryMethodInterface {
    	Reader create(File file) throws FileNotFoundException;
}
```

**Spring中FactoryBean对象就是对工厂方法模式的最好实践。**



相比于简单工厂模式来说，**工厂方法模式不局限于单一的工厂类**。

在使用工厂方法模式的时候，如果抽象接口也只有单一继承，那么也就退化为了简单工厂模式。

但总得来说工厂方法模式中，**一个工厂类仍局限于单个的产品类，并且增加产品类就需要创建新的工厂实现类的设定，一定程度上增加了编码的复杂性。**



### 抽象工厂模式

如果说从简单工厂模式到工厂方法模式，是提取了公用的方法接口，扩展了工厂类。

**那么抽象工厂接口就是扩展了产品类，产品也不仅仅局限于一种。**

对应的产品类的扩展，工厂创建类的创建方法数也增加了。

类图如下：

![image-20200614205201515](/home/chen/github/_java/pic/image-20200614205201515.png)

继续拿Reader举例，此时如果需要添加一个Writer类，假设不同的Reader和Writer是一种对应关系，此时就的工厂方法模式可能就有点顶不住了。

根据抽象方法模式实现之后如下：

```java
    class BufferReaderFactory implements AbstractFactoryInterface {
            @Override
            public BufferedReader createReader(File file) throws FileNotFoundException {
                    final FileInputStream in = new FileInputStream(file);
                    final InputStreamReader in1 = new InputStreamReader(in);
                    return new BufferedReader(in1);
            }

            @Override
            public Writer createWriter(File file) throws FileNotFoundException {
                    final FileOutputStream out = new FileOutputStream(file);
                    final OutputStreamWriter outputStreamWriter = new OutputStreamWriter(out);
                    return new BufferedWriter(outputStreamWriter);
            }
    }

    class FileReaderFactory implements AbstractFactoryInterface {
            @Override
            public Reader createReader(File file) throws FileNotFoundException {
                	return new FileReader(file);
            }

            @Override
            public Writer createWriter(File file) throws IOException {
                	return new FileWriter(file);
            }
    }
	//  抽象工厂接口
    interface AbstractFactoryInterface {
        Reader createReader(File file) throws FileNotFoundException;

        Writer createWriter(File file) throws IOException;
    }
```



### 工厂模式总结

理论上说简单工厂模式已经拥有了工厂模式的核心，以工厂的概念抽离出对象创建的逻辑，实现对象创建和使用的解耦。

但是简单工厂模式有以下几个缺点：

1. 不符合开闭原则，难以扩展。
2. 单工厂的逻辑过重，承载了太多的创建逻辑。

产品族单一的问题，在我看来在Java中可能并没有那么大影响，以Object类作为返回值就能支持不同的产品。

针对以上问题，就有了工厂方法模式，工厂方法模式在简单工厂模式的基础上，利用不同的子类实现来分散单工厂的逻辑。

并且利用继承统一接口的形式也便于扩展，新增产品。

工厂方法模式可以说已经不错了，抽象程度也足够了，但是在一个工厂类一个创建方法的形式下，很难描述具有关联关系的不同的产品类。

**所以在工厂方法模式的基础上，新增的不同的工厂方法，应对多个关联产品。**

个人感觉，这个关联关系很重要，如果用一个抽象工厂模式实现两个完全不搭边的产品的创建，那就又回到了简单工厂模式，以新增方法的形式去兼容新产品的加入。



### 建造者模式

建造者模式也是一种创建型模式，不同于工厂模式完全分离对象创建和使用的逻辑，意思是它只关心创建，而不关心创建的过程。

而建造者模式不同，**它拆分了对象的创建过成，对创建的流程进行抽象。**

类图如下：

 ![image-20200614235109806](/home/chen/github/_java/pic/image-20200614235109806.png)

其中产品类的接口定义了产品的一些基本属性，创建者接口定义了对这些基本属性构建方法，而指挥者类则是调用实际的创建者方法，最终生成一个产品。

我们可以用电脑组装的过程为例子来理解：

```java
 class Director{
            private Builder interBuilder = new InterBuilder();
            private Builder amdBuilder = new AMDBuilder();

            public Computer builder(){
                    final Computer computer = new Computer();
                    computer.cpu = interBuilder.cpu();
                    computer.memory = amdBuilder.memory();
                    return computer;
            }

    }

    class Computer{
        private String cpu;
        private String memory;
    }

    interface Builder{
            String cpu();
            String memory();
    }

    class InterBuilder implements Builder{
            @Override
            public String cpu() {
                    return "Inter CPU";
            }
            @Override
            public String memory() {
                	return "Inter Memory";
            }
    }

    class AMDBuilder implements Builder{
            @Override
            public String cpu() {
                	return "AMD CPU";
            }
            @Override
            public String memory() {
                	return "AMD Memory";
            }
    }

```







## 结构型模式

### 代理模式

### 适配器模式

### 桥接模式

### 装饰模式

### 外观模式

### 享元模式

### 组合模式



## 行为型模式

### 模板模式

### 策略模式

### 命令模式

### 责任链模式

### 状态模式

### 观察者模式

### 中介者模式

### 迭代器模式

### 访问者模式

### 备忘录模式

### 解释器模式



