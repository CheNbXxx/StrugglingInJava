# 23种基本设计模式

> 2020/06/08
> 半个月没看技术相关的了，希望通过对设计模式的重新整理找回学习的状态吧。



---



## 设计模式的七大法则

也可以理解为好的代码结构需要遵守的七大法则。



### 开闭原则

对扩展开放，对修改关闭。

对扩展开放的意思，在我理解中就是类应该要易于扩展，有什么功能变更的或者添加的时候不应该直接去改主逻辑，而是通过扩展的形式。



### 里氏替换原则

替换就是指在所有使用父类的地方，可以用子类代替。

也就是说子类必须扩展父类的原有功能，但不能修改原有的功能。

里氏替换原则可以说是开闭原则的具体实现或者说进一步补充。



### 依赖倒置原则

类之间的依赖需要按照一定的规则顺序，高层抽象类不能依赖底层的具体实现。

比如在接口方法中定义子类为入参类型。

违背依赖倒置原则会大大增加类间的耦合性不利于代码维护。



### 单一职责原则

简单理解就是希望类的功能尽量单一，一个类不应该承载太多的职责。

降低类的复杂度，减小类的实现粒度，都有利于减小类之间的耦合性，方便后期维护。



### 接口隔离原则

和单一职责原则很相似，在我理解可能就是规定的对象不同，接口隔离就是特指接口。

面向接口编程，一个接口不应该承载太多的特性。

简单理解该原则，可能就是规定接口的粒度需要尽量的小。

比如Java中的Closeable之类的接口？或者Spring中的各类顶级接口。



### 合成复用原则

该原则规定，要**尽量使用组合或者聚合等关联关系来代替继承关系来实现类之间的关联。**

继承就表示子类和父类之间的高耦合度，父类的任何改动都会影响到子类，且对子类会产生一些约束和限制，不利于扩展。



### 迪米特法则

该法则规定如果两个类没有直接关系，那么就不应该产生直接的相互调用，可以通过第三方转发该调用。

该法则提高了类之间的独立性，降低了耦合度。

SpringBoot中对BeanFactoryPostProcessor的调用可能就是这个法则吧。





## 设计模式的分类

根据目的来分设计模式可以分为创建型，结构型和行为型。

创建型模式主要着力于对象的创建过程，将创建和使用过程分离。

结构型模式主要着力于对象的继承和实现，如果通过一些基本接口和对象组成一个更大的结构，和期间应该注意的点。

行为型模式主要描述类之间的调用关系，规范化方法和方法的职责，用于描述类或对象之间协作的过程。



## 创建型模式

### 单例模式

最常用的设计模式之一。

单例模式必须保证类实例在系统中的唯一性，好处估计也不用我多说。

类似一些重量级对象都可以使用单例模式实现，提供一个全局的访问点。

单例模式主要有以下几个特点：

1. 构造函数私有化，阻止类外部的初始化
2. 类内部持有自身实例引用
3. 提供一个对外的获取接口

类图如下：

 ![image-20200610235339938](/home/chen/github/_java/pic/image-20200610235339938.png)

单例模式的持有和创建都在类自身里面。

基本的单例模式如下：

首先是饿汉模式：

```java
public class HungrySingle{
    	// 内部持有实例引用
    	private static final HungrySingle INSTANCE = new HungrySingle();
    	
    	// 私有化构造函数
    	private HungrySingle(){
            	// 私有化之后，JVM也不会自动生成一个public的无参构造
        }
    
    	// 提供统一的话获取方法
    	public static HungrySingle getInstance(){
            	return INSTANCE;
        }
}
```

饿汉模式的特点就是在类加载时候就会实例化对象，通过JVM的类加载机制保证实例的唯一性。

对于静态变量，在准备阶段就会分配一个系统的默认值。

而另外一种懒汉模式，则是在此基础上增加了懒加载的特性只有在需要的时候才会调用。

```java
public class LazySingle{
    	private static final LazySingle INSTANCE;
    
    	private LazySingle(){}
    
    	public static LazySingle getInstance(){
            	if(INSTANCE == null){
                    	INSTANCE = new LazySingle();
                } 
            	return INSTANCE;
        }
}
```

只有在第一次调用getInstance方法的时候才会初始化实例对象。

但以上代码并非是线程安全的，多线程环境下可能仍然会创建多个实例对象。

为了保证懒汉模式的线程安全性，确保只会实例对象的唯一性，又有了静态内部类，枚举以及耳熟能详的双重检查锁模式。

以下是双重检查锁的getInstance方法：

```java
public class LazySingle{
    	private volatile static final LazySingle INSTANCE;
    
    	private LazySingle(){}

        public static LazySingle getInstance(){
            if(INSTANCE == null){
                    synchronized(LazySingle.class){
                            if(INSTANCE == null){
                                	INSTANCE = new LazySingle();
                            }
                    }
            }

            return INSTANCE;
        }
}
```

使用了synchronized来保证创建过程的线程安全，用volatile保证INSTANCE的可见性。

在外先判断是否为空是必然的，而第二次加锁则是为了避免多个线程同时等待锁释放后的再一次初始化。

另外，因为在Java中`INSTANCE = new LazySingle()`并不是原子操作，简单来说先创建对象实例，然后将INSTANCE引用指向创建的实例，所以也需要volatile关键字保证INSTANCE在多线程环境下的可见性。

静态内部类的实现方式如下：

```java
public class LazySingle{
    
    	private LazySingle(){}
    
    	private static class InstanceHolder{
            	private static final LazySingle INSTANCE = new LazySingle();
        }
    	
    	public static getLazySingle(){
            	return InstanceHolder.INSTANCE;
        }
}
```

可以看到唯一实例其实是内部类持有的。

在加载外部类的时候并不会直接加载内部类，只有在使用到内部类的相关属性的时候才会去进一步加载

也就是说只有在调用getLazySingle方法的时候，因为使用了InstanceHolder类才会去加载内部类，而静态变量也会在类加载的过程中完成初始化。

另外就是effective java作者也强烈推荐的枚举类实现方式：

```java
public class LazySingle{
    	private LazySingle(){}
    
    	private enum  InstanceHolder{
            
            	INSTANCE;
            	
            	private final LazySingle single;
            
            	InstanceHolder(){
                    	single = new LazySingle();
                }
            
            	private LazySingle getSingle(){
                    	return single;
                }
        }
    	
    	public static getLazySingle(){
            	return InstanceHolder.INSTANCE.getSingle();
        }
}
```

该种实现方式充分利用了枚举类型的特性，保证了加载的线程安全性和实例对象的唯一性。

而且是所有单利模式中唯一一种免疫序列化，反射和克隆三种破坏形式的实现。

这几种破坏方式我也没有仔细去看过，恩，单例就这样吧。





### 原型模式

### 工厂方法模式

### 抽象工厂模式

### 建造者模式



## 结构型模式

### 代理模式

### 适配器模式

### 桥接模式

### 装饰模式

### 外观模式

### 享元模式

### 组合模式



## 行为型模式

### 模板模式

### 策略模式

### 命令模式

### 责任链模式

### 状态模式

### 观察者模式

### 中介者模式

### 迭代器模式

### 访问者模式

### 备忘录模式

### 解释器模式



