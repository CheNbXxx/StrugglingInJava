# Raft

> 6.824的lab2b，总有一个用例无法完全通过，有点乱了，就先整理以下内容吧。



## 状态机

状态机，一般指有限状态机（finite-state machine），表示的是一种有限个`状态`以及在这些状态之间的转换和动作的数学模型。

理论上来说，对于一个状态机，**当前状态一定，输入一定时，最终的状态也是一定的。**

## 复制状态机

复制状态机，或者称状态机复制，是在分布式领域，对于提升容错能力常用的方法。

理论基础就是对于所有起始状态相同(**S**)的节点，那么给予这些节点相同的输入序列: *{i1, i2, i3, i4, i5, i6, …, in}*, 这些状态机必然会经过相同的状态转换路径: *s0->s1->s2->s3->…->sn*最终达到相同的状态sn, 同时生成相同的输出序列 *{o1(s1), o2(s2), o3(s3), …, on(sn)}*。



以上是我对Raft论文中第二章节的理解，也是整个的理论基础，接下来是结合实际的Raft算法的实现部分。

## Raft中的状态机模型

 ![Raft 一致性算法论文译文](/home/chen/github/_java/pic/mfESApyVoB1cPRe.png)



Raft中的每个节点的都会具有上述三个状态中的一个：

1. Leader - 领导者
2. Follower - 跟随者
3. Candidate - 候选者



所有节点在**启动的时候都为Follower状**。

在超时时间内未收到Leader的心跳就会进入到Candidate状态，并开启选举。

如果选举中节点获得大多数(过半)的投票，那么它就会晋升到Leader节点。

Leader节点如果发现term比它更大的节点，则会主动退位到Follower节点。

Candidate在发起选举后发现当前领导者或者更大的term以及选举失败都会退回Follower节点。





![](/home/chen/github/_java/pic/d4b906bd24fc2e85925f132122573f59.jpg) 



term可以看作是epoch，在每个节点中都会保存，表明当前的任期或者时代。

在每次触发选举的时候+1，并且在选举完成后传递到所有Follower节点。

Raft中有一条铁律，就是term大的节点话语权更大，节点永远不会处理term比自己小的请求。

因此也不难看出来，Raft算法对拜占庭问题是一点办法都没有的。





## Raft算法

Raft算法中将整个共识流程拆分成三个相对独立的子问题:

1. 领导选举
2. 日志复制
3. 安全性



### 领导选举